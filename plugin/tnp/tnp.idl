namespace torque {

[binding_model=by_value, include="torque_sockets_cpp.h"]
class event
{	
	enum type
	{
		connection_challenge_response_event_type = 1,
		connection_requested_event_type,
		connection_arranged_connection_request_event_type,
		connection_accepted_event_type,
		connection_rejected_event_type,
		connection_timed_out_event_type,
		connection_disconnected_event_type,
		connection_established_event_type,
		connection_packet_event_type,
		connection_packet_notify_event_type,
		socket_packet_event_type
	};
	
	[getter] type event_type_;
	[getter] connection source_connection_;
	[getter] connection introducer_;
	[getter] std::string client_identity_;
	[getter] std::string public_key_;
	[getter] std::string data_;
	[getter] unsigned int packet_sequence_;
	[getter] bool delivered_;
	[getter] std::string source_address_;
};

[binding_model=by_value, include="torque_sockets_cpp.h"]
class send_result
{
	[getter] bool sent;
	[getter] unsigned int packet_sequence;
};

[binding_model=by_value, include="torque_sockets_cpp.h"]
class connection
{
	connection introduce_me(std::string remote_client, std::string connect_data);

	void accept(std::string accept_data);
	void reject(std::string reject_data);
	
	send_result send(std::string data);

	void disconnect(std::string disconnect_data);
};

[binding_model=by_pointer, include="torque_sockets_cpp.h"]
class socket
{
	socket(std::string addy);
	[getter=does_allow_incoming_connections, setter=allow_incoming_connections] bool allow_incoming_connections;
	[getter=is_introducer, setter=can_be_introducer] bool can_be_introducer;
	
	void seed_entropy(std::string entropy);
	
	connection connect(std::string address, std::string connect_data);
	event get_next_event();
};

}
