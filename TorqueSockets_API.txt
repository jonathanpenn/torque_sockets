The TorqueSockets API

Draft 1 March 20, 2010

Abstract

This specification defines a proposed API that enables Web pages to use the TorqueSockets protocol for two-way real-time communication with remote hosts.

Status of This document

This section describes the status of this document at the time of its publication. Other documents may supersede this document.

If you wish to make comments regarding this document, please send them to ???. All feedback is welcome.

Implementors should be aware that this specification is not stable. Implementors who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation stage should join the aforementioned mailing lists (once they truly are mentioned afore) and take part in the discussions.

The latest stable version of the editor's draft of this specification is always available on nardo's torque_sockets github repository: http://github.com/nardo/torque_sockets/blob/master/TorqueSockets_API.txt

1 Introduction
--------------

To enable Web applications (specifically real-time multiplayer client/server and peer-to-peer games, communication tools) to maintain bidirectional, efficient real-time communications with server-side processes and introduced-host processes, this specification introduces the TorqueSockets interface.

The high level goals of the TorqueSockets interface are:

* minimal footprint, API attack surface
* packet-based protocol to match underlying (UDP) transport
* low per-packet overhead
* connection-based, prevent raw access to underlying network
* app-determined policy for send frequency and throughput

Specifically, the handshake negotiation goals include:

2 phase connect
client-puzzle challenge response for improved DOS protection
replicate "same origin" policies
enable peer host connection introduction (peer-to-peer or multi-server)
key exchange, public key validation option by web app code

Connection packet protocol:

Low per-packet protocol overhead (min-target 4 bytes/packet)
Variable-width packet window protocol (currently implemented as constants)
Packet delivery status notification (unreliable delivery, reliable notification)
Duplicate, out-of-order packet rejection
Variable-length packet signature (prototype implements as SHA-256, variable byte width recorded) 
Symmetric key encryption (prototype implements as 128-bit AES)

This interface does not allow for raw access to the underlying network.

2 References
------------

This specification and prototype implementation draw from several reference sources:

The WebSocket API - used for patterning in-browser JavaScript API - http://dev.w3.org/html5/websockets/
OpenTNL 1.5 - open source game networking library based on Torque Game Engine network model - hosted at: http://github.com/nardo/torque_network_library_1_5
Game Networking Resources - conceptual introduction to real-time game networking - http://gafferongames.com/2009/01/25/game-networking-resources/
Tribes Engine Networking Model - Game Developer's Conference 2000 Proceedings - http://www710.univ-lyon1.fr/~jciehl/Public/educ/GAMA/2008/tribes_networking_model.pdf
The torque_sockets C API  

3 The TorqueSockets interface
-----------------------------

[Constructor()]
interface TorqueSockets {
	set_private_key(in DOMString private_key);
	set_challenge_response(in DOMString challenge_response);
	int connect(in DOMString URL, in DOMString connect_data, in optional DOMString protocol_settings);
	int connect_introduced (in int introducer, in int remote_client_connection_id, bool is_host, in DOMString connect_data);
	int introduce(in int initiator_connection, in int host_connection);
	accept_challenge(in int pending_connection);
	accept_connection(in int pending_connection);
	close(in int connection_id, in optional DOMString reason_data);
	unsigned long send_to(in int connection_id, DOMString packet_data);

	attribute Function on_challenge_response;
	attribute Function on_connect_request;
	attribute Function on_close;
	attribute Function on_packet;
	attribute Function on_packet_delivery_notify;
	attribute Function on_connection_established;
};

interface description to follow.

4 Detailed connection handshake overview
----------------------------------------

torque_sockets does a two phase connect handshake to prevent a several types of Denial-of-Service (DoS) attacks.

The connection initiator starts the connection by sending a unique random nonce (number, used once) value to the host as part of the connect_challenge_request packet.

initiator->host: connect_challenge_request(initiator_nonce)

The host responds to the connect_challenge_request with a "Client Puzzle" that has the property that verifying a solution to the puzzle is computationally simple, but can be of a specified computational, brute-force difficulty to compute the solution itself.  The client puzzle is of the form: secureHash(Ic, initiator_nonce, host_nonce, X) = Y >> k, where Ic is the identity of the client, and X is a value computed by the client such that the high k bits of the value y are all zero.  The client identity is computed by the server as a partial hash of the client's IP address and port and some random data on the host.  The response contains the host's current nonce, the initiator nonce, k, the host's public key and any data set via set_challenge_response_data

host->initiator: connect_challenge_response(initiator_nonce, host_nonce, k, host_public_key, host_challenge_response_data)

The initiator, upon receipt of the connect_challenge_response, validates the packet sent by the host and computes a solution to the puzzle the host sent.  The initiator generates a shared secret from the initiator's key pair and the host's public key.  The initiator response to the host consists of:

initiator->host: connect_request(initiator_nonce, host_nonce, X, initiator_public_key, shared_secret(key1, sequence1, connect_request_data))

The host then can validation the solution to the puzzle the initiator submitted, along with the client identity (Ic).  Until this point the host has allocated no memory for the initiator and has verified that the initiator is sending from a valid IP address, and that the initiator has done some amount of work to prove its willingness to start a connection.  As the host load increases, the host may choose to increase the difficulty (k) of the client puzzles it issues, thereby making a CPU/connection resource depletion DoS attack successively more difficult to launch.

If the server accepts the connection, it sends a connect accept packet that is encrypted and hashed using the shared secret.  The contents of the packet are another sequence number (sequence2) and another key (key2).  The sequence numbers are the initial send and receive sequence numbers for the torque_connection protocol, and the key2 value becomes the IV of the symmetric cipher.  The connection_accept_data is also sent and encrypted in this channel.

Connections using the secure key exchange are still vulnerable to Man-in-the-middle attacks.  Using a key signed by a trusted certificate authority (CA), makes the communications channel as securely trusted as the trust in the CA.  This could be implemented by the host sending its certificate and a signature of the public key down in the challenge_response_data

Introduced Connection handshaking: (not implemented yet)

torque_socket can also facilitate introduced connections.  Introduced connections are necessary when both parties to the connection are behind firewalls or NAT routers, or don't want to accept anonymous connections from the network.  Suppose there are two processes, initiator and host that want to establish a direct connection and that those two processes are connected to the same third party introducer.  All three parties can simultaneously initiate an introduced connection by calling the appropriate methods on their torque_socket instances.  The protocol works as follows:

initiator/host->introducer: request_introduction(remote_connection_id, shared_secret(initiator/host _nonce))

introducer->initiator/host: introduction_response( shared_secret( remote_public_addresses, introduced_connection_shared_secret, remote_nonce ) )

The remote public addresses are the public (NAT'd) address of the hosts from the perspective of the introducer, as well as the IP addresses each client detects for itself including local network address and external addresses as determined from the router by UPnP and/or Bonjour APIs (not implemented yet!).

Once the initiator and host receive introduction_responses, they being sending "punch" packets to the known possible addresses of each other.  The punch packet I sends enables the punch packet H sends to be delivered through the router or firewall since it will appear as though it is a service response to I's initial packet, and vice versa.

Upon receipt of the punch packet by the host of the connection, the initiator engages the normal connection process (challenge request/response, connect request/response).  If the host of the introduced connection gets challenge request it stops sending punch packets to the potential addresses.

5 Detailed wire protocol description
------------------------------------

to be written.
