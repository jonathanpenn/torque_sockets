/// All data associated with the negotiation of the connection
class pending_connection : public ref_object
{
public:
	/// enum of possible states of a pending connection.  A pending connection can be created in one of four states: initiator, host, introduced initiator, introduced host.  In the case of an introduced connection, the initial state will be requesting_introduction.  A connection created as an initiator will begin in the requesting_challenge_response state, and a pending_connection host will be created in the awaiting_local_accept state.
	enum pending_connection_state {
		
		requesting_introduction, ///< Requesting the address and shared secret for connection to an introduced initiator or host
		sending_punch_packets, ///< The state of a pending introduced connection when both sides haven't heard from the other yet
		awaiting_initiator_challenge, ///< The introduced host moves into this state after receiving punch confirmation.
		
		requesting_challenge_response, ///< This initiator is sending challenge requests, awaiting the response.  An introdced initiator will move into this state after punch confirmation.
		awaiting_local_challenge_accept, ///< This pending connection is awaiting either an accept_connection_challenge or a disconnect call to the socket for this connection.  A pending connection initiator will be in this state after receiving a challenge response from the host.
		
		awaiting_connect_request, ///< this introduced connection has received a challenge request, response sent, awaiting connect packet
		computing_puzzle_solution, ///< This initiator has accepted a challenge response, and is in the process of computing a solution to the client puzzle offered by the host.
		requesting_connection, ///< After computing the puzzle solution, this initiator is now requesting a connection to the host.
		awaiting_local_accept, ///< This pending connection is is awaiting either an accept_connection or disconnect call.
		connected, ///< The connection is connected.  A pending connection is removed from the initiator side once a connect_accept packet is received, but has to stay around on the host side until a data packet is properly received for the connection, in case the connect accept packet needs to be re-sent.
		
		pending_connection_state_count,
	};
	enum pending_connection_type
	{
		connection_initiator,
		connection_host,
		introduced_connection_initiator,
		introduced_connection_host,
	};
	
	/// Sets the current connection state of this connection.
	void set_state(connection_state state)
	{
		_state = state;
	}
	
	/// Gets the current connection state of this connection.
	connection_state get_state()
	{
		return _state;
	}

	pending_connection(pending_connection_type type, torque_socket *the_socket, uint32 connection_index)
	{
		_type = type;
		if(type == connection_initiator)
			_state = requesting_challenge_response;
		else if(type == connection_host)
			_state = awaiting_local_accept;
		else
			_state = requesting_introduction;
		_state_send_count = 0;
		_puzzle_retried = false;
		_socket = the_socket;
		_connection_index = connection_index;
	}
	
	pending_connection_type _type; ///< the type of this pending connection
	pending_connection_state _state, /// the current state of this pending connection
	safe_ptr<torque_socket> _socket; ///< the socket this connection is pending on.
	uint32 _connection_index; ///< the index of this connection on the socket
	array<address> _possible_addresses; ///< List of possible addresses for the remote host in an introduced connection.	
	bool _puzzle_retried; ///< True if a puzzle solution was already rejected by the host once.	
	uint8 _symmetric_key[symmetric_cipher::key_size]; ///< The symmetric key for the connection, generated by the initiator
	uint8 _init_vector[symmetric_cipher::key_size]; ///< The init vector, generated by the host
	
	uint32 _puzzle_difficulty; ///< Difficulty of the client puzzle solved by this client.
	uint32 _puzzle_solution; ///< Solution to the client puzzle the host sends to the initiator.
	uint32 _client_identity; ///< The client identity as computed by the host - basically a hash of the client's address, nonce and some special random data on the host.
	
	uint32 _puzzle_request_index; ///< The index of the puzzle solver thread queue request.
	ref_ptr<asymmetric_key> _public_key; ///< The public key of the remote host.
	ref_ptr<asymmetric_key> _private_key;///< The private key for this connection.  May be generated on the connection attempt.
	
	byte_buffer_ptr _arranged_secret; ///< The shared secret for the introduced connection, generated by the introducer.  Note that unless the peers have some way to validate each other's public keys (upon challenge/connect), the connection will be vulnerable to a man-in-the-middle attack from an untrustworthy introducer.
	
	uint32 _state_send_retry_count; ///< number of requests to send before timing out while the pending_connection is in this state.
	uint32 _state_send_retry_interval;
	
	time _state_last_send_time; ///< The send time of the last challenge or connect request.
	byte_buffer_ptr _packet_data; ///< data sent along with this connection request, connection accept, 
};

