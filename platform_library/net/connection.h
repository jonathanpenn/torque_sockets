/// NetConnectionRep maintains a linked list of valid connection classes.
struct NetConnectionRep
{
   static NetConnectionRep *mLinkedList;

   NetConnectionRep *mNext;
   ClassRep *mClassRep;
   bool mCanRemoteCreate;

   NetConnectionRep(ClassRep *classRep, bool canRemoteCreate)
   {
      mNext = mLinkedList;
      mLinkedList = this;
      mClassRep = classRep;
      mCanRemoteCreate = canRemoteCreate;
   }
   static NetConnection *create(const char *name)
	{
	   for(NetConnectionRep *walk = mLinkedList; walk; walk = walk->mNext)
		  if(walk->mCanRemoteCreate && !strcmp(name, walk->mClassRep->getClassName()))
		  {
			 Object *obj = walk->mClassRep->create();
			 NetConnection *ret = dynamic_cast<NetConnection *>(obj);
			 Assert(ret != NULL, "Invalid TNL_IMPLEMENT_NETCONNECTION");
			 if(!ret)
				delete obj;
			 return ret;
		  }

	   return NULL;
	}

};
NetConnectionRep *NetConnectionRep::mLinkedList = NULL;

#define TNL_DECLARE_NETCONNECTION(className, parentClass) \
   TORQUE_DECLARE_CLASS(className, parentClass); \
   Torque::NetClassGroup getNetClassGroup() const

#define TNL_IMPLEMENT_NETCONNECTION(className, classGroup, canRemoteCreate) \
   TORQUE_IMPLEMENT_CLASS(className); \
   Torque::NetClassGroup className::getNetClassGroup() const { return classGroup; } \
   static Torque::NetConnectionRep g##className##Rep(&className::dynClassRep, canRemoteCreate)

static const char *packetTypeNames[] = 
{
   "DataPacket",
   "PingPacket",
   "AckPacket",
};

/// All data associated with the negotiation of the connection
struct ConnectionParameters
{
   bool mIsArranged;                 ///< True if this is an arranged connection
   bool mUsingCrypto;                ///< Set to true if this connection is using crypto (public key and symmetric)
   bool mPuzzleRetried;              ///< True if a puzzle solution was already rejected by the server once.
   Nonce mNonce;                     ///< Unique nonce generated for this connection to send to the server.
   Nonce mServerNonce;               ///< Unique nonce generated by the server for the connection.
   U32 mPuzzleDifficulty;            ///< Difficulty of the client puzzle solved by this client.
   U32 mPuzzleSolution;              ///< Solution to the client puzzle the server sends to the client.
   U32 mClientIdentity;              ///< The client identity as computed by the remote host.
   RefPtr<AsymmetricKey> mPublicKey; ///< The public key of the remote host.
   RefPtr<AsymmetricKey> mPrivateKey;///< The private key for this connection.  May be generated on the connection attempt.
   RefPtr<Certificate> mCertificate; ///< The certificate of the remote host.
   ByteBufferPtr mSharedSecret;      ///< The shared secret key 
   bool mRequestKeyExchange;         ///< The initiator of the connection wants a secure key exchange
   bool mRequestCertificate;         ///< The client is requesting a certificate
   U8 mSymmetricKey[SymmetricCipher::KeySize]; ///< The symmetric key for the connection, generated by the client
   U8 mInitVector[SymmetricCipher::KeySize]; ///< The init vector, generated by the server
   Array<NetAddress> mPossibleAddresses; ///< List of possible addresses for the remote host in an arranged connection.
   bool mIsInitiator;                ///< True if this host initiated the arranged connection.
   bool mIsLocal;                    ///< True if this is a connectLocal connection.
   ByteBufferPtr mArrangedSecret;    ///< The shared secret as arranged by the connection intermediary.
   bool mDebugObjectSizes;           ///< This connection's initiator requested debugging size information during packet writes.

   ConnectionParameters()
   {
      mIsInitiator = false;
      mPuzzleRetried = false;
      mUsingCrypto = false;
      mIsArranged = false;
#ifdef TORQUE_DEBUG
      mDebugObjectSizes = true;
#else
      mDebugObjectSizes = false;     
#endif
      mIsLocal = false;
   }
};

//----------------------------------------------------------------------------
/// TNL network connection base class.
///
/// NetConnection is the base class for the connection classes in TNL. It implements a
/// notification protocol on the unreliable packet transport of UDP (via the TNL::Net layer).
/// NetConnection manages the flow of packets over the network, and calls its subclasses
/// to read and write packet data, as well as handle packet delivery notification.
///
/// Because string data can easily soak up network bandwidth, for
/// efficiency NetConnection implements an optional networked string table.
/// Users can then notify the connection of strings it references often, such as player names,
/// and transmit only a tag, instead of the whole string.
///
class NetConnection : public Object
{
   friend class NetInterface;
   friend class ConnectionStringTable;

   typedef Object Parent;
   
   String mErrorString;

   /// Constants controlling the data representation of each packet header
   enum HeaderConstants {
      // NOTE - IMPORTANT!
      // The first bytes of each packet are made up of:
      // 1 bit - game data packet flag
      // 2 bits - packet type
      // SequenceNumberBitSize bits - sequence number
      // AckSequenceNumberBitSize bits - high ack sequence received
      // these values should be set to align to a byte boundary, otherwise
      // bits will just be wasted.

      MaxPacketWindowSizeShift = 5,                            ///< Packet window size is 2^MaxPacketWindowSizeShift.
      MaxPacketWindowSize = (1 << MaxPacketWindowSizeShift),   ///< Maximum number of packets in the packet window.
      PacketWindowMask = MaxPacketWindowSize - 1,              ///< Mask for accessing the packet window.
      MaxAckMaskSize = 1 << (MaxPacketWindowSizeShift - 5),    ///< Each ack word can ack 32 packets.
      MaxAckByteCount = MaxAckMaskSize << 2,                   ///< The maximum number of ack bytes sent in each packet.
      SequenceNumberBitSize = 11,                              ///< Bit size of the send and sequence number.
      SequenceNumberWindowSize = (1 << SequenceNumberBitSize), ///< Size of the send sequence number window.
      SequenceNumberMask = -SequenceNumberWindowSize,          ///< Mask used to reconstruct the full send sequence number of the packet from the partial sequence number sent.
      AckSequenceNumberBitSize = 10,                           ///< Bit size of the ack receive sequence number.
      AckSequenceNumberWindowSize = (1 << AckSequenceNumberBitSize), ///< Size of the ack receive sequence number window.
      AckSequenceNumberMask = -AckSequenceNumberWindowSize,          ///< Mask used to reconstruct the full ack receive sequence number of the packet from the partial sequence number sent.

      PacketHeaderBitSize = 3 + AckSequenceNumberBitSize + SequenceNumberBitSize, ///< Size, in bits, of the packet header sequence number section
      PacketHeaderByteSize = (PacketHeaderBitSize + 7) >> 3, ///< Size, in bytes, of the packet header sequence number information
      PacketHeaderPadBits = (PacketHeaderByteSize << 3) - PacketHeaderBitSize, ///< Padding bits to get header bytes to align on a byte boundary, for encryption purposes.

      MessageSignatureBytes = 5, ///< Special data bytes written into the end of the packet to guarantee data consistency
   };
   Time mLastPacketRecvTime; ///< Time of the receipt of the last data packet.
   U32 mLastSeqRecvdAtSend[MaxPacketWindowSize]; ///< The sequence number of the last packet received from the remote host when we sent the packet with sequence X & PacketWindowMask.
   U32 mLastSeqRecvd;                            ///< The sequence number of the most recently received packet from the remote host.
   U32 mHighestAckedSeq;                         ///< The highest sequence number the remote side has acknowledged.
   U32 mLastSendSeq;                             ///< The sequence number of the last packet sent.
   U32 mAckMask[MaxAckMaskSize];                 ///< long string of bits, each acking a packet sent by the remote host.
                                                 ///< The bit associated with mLastSeqRecvd is the low bit of the 0'th word of mAckMask.
   U32 mLastRecvAckAck; ///< The highest sequence this side knows the other side has received an ACK or NACK for.

   U32 mInitialSendSeq; ///< The first mLastSendSeq for this side of the connection.
   U32 mInitialRecvSeq; ///< The first mLastSeqRecvd (the first mLastSendSeq for the remote host).
   Time mHighestAckedSendTime; ///< The send time of the highest packet sequence acked by the remote host.  Used in the computation of round trip time.
   /// Two-bit identifier for each connected packet.
   enum NetPacketType
   {
      DataPacket, ///< Standard data packet.  Each data packet sent increments the current packet sequence number (mLastSendSeq).
      PingPacket, ///< Ping packet, sent if this instance hasn't heard from the remote host for a while.  Sending a
                  ///  ping packet does not increment the packet sequence number.
      AckPacket,  ///< Packet sent in response to a ping packet.  Sending an ack packet does not increment the sequence number.
      InvalidPacketType,
   };
   /// Constants controlling the behavior of pings and timeouts
   enum DefaultPingConstants {
      AdaptiveInitialPingTimeout = 60000,
      AdaptivePingRetryCount = 4,
      DefaultPingTimeout = 5000,  ///< Default milliseconds to wait before sending a ping packet.
      DefaultPingRetryCount = 10, ///< Default number of unacknowledged pings to send before timing out.
      AdaptiveUnackedSentPingTimeout = 3000,
   };
   Time mPingTimeout; ///< time to wait before sending a ping packet.
   U32 mPingRetryCount; ///< Number of unacknowledged pings to send before timing out.

   /// Returns true if this connection has sent packets that have not yet been acked by the remote host.
   bool hasUnackedSentPackets() { return mLastSendSeq != mHighestAckedSeq; }
public:
   struct PacketNotify;

   NetConnection()
	{
	   mInitialSendSeq = Random::readI();
	   Random::read(mConnectionParameters.mNonce.data, Nonce::NonceSize);

	   mSimulatedLatency = 0;
	   mSimulatedPacketLoss = 0;

	   mRoundTripTime = 0;
	   mSendDelayCredit = millisecondsToTime(0);
	   mConnectionState = NotConnected;
	   
	   mNotifyQueueHead = NULL;
	   mNotifyQueueTail = NULL;
	   
	   mLocalRate.maxRecvBandwidth = DefaultFixedBandwidth;
	   mLocalRate.maxSendBandwidth = DefaultFixedBandwidth;
	   mLocalRate.minPacketRecvPeriod = DefaultFixedSendPeriod;
	   mLocalRate.minPacketSendPeriod = DefaultFixedSendPeriod;

	   mRemoteRate = mLocalRate;
	   mLocalRateChanged = true;
	   computeNegotiatedRate();

	   mPingSendCount = 0;

	   mLastSeqRecvd = 0;
	   mHighestAckedSeq = mInitialSendSeq;
	   mLastSendSeq = mInitialSendSeq; // start sending at mInitialSendSeq + 1
	   mAckMask[0] = 0;
	   mLastRecvAckAck = 0;

	   // Adaptive
	   cwnd = 2;
	   ssthresh = 30;
	   mLastSeqRecvdAck = 0;

	   mPingTimeout = millisecondsToTime(DefaultPingTimeout);
	   mPingRetryCount = DefaultPingRetryCount;
	   mStringTable = NULL;
	}


   ~NetConnection()
	{
	   clearAllPacketNotifies();
	   delete mStringTable;

	   Assert(mNotifyQueueHead == NULL, "Uncleared notifies remain.");
	}

   enum TerminationReason {
      ReasonTimedOut,
      ReasonFailedConnectHandshake,
      ReasonRemoteHostRejectedConnection,
      ReasonRemoteDisconnectPacket,
      ReasonDuplicateConnectionAttempt,
      ReasonSelfDisconnect,
      ReasonError,
   };

protected:
	/// Called when a pending connection is terminated
	virtual void onConnectTerminated(TerminationReason reason, const char *rejectionString)
	{
	}

	/// Called when this established connection is terminated for any reason
	virtual void onConnectionTerminated(TerminationReason, const char *errorDisconnectString)
	{
	}
   
   /// Called when the connection is successfully established with the remote host.
   virtual void onConnectionEstablished()
	{
	   if(isInitiator())
		  setIsConnectionToServer();
	   else
		  setIsConnectionToClient();
	}

   /// validates that the given certificate is a valid certificate for this
   /// connection.
   virtual bool validateCertficate(Certificate *theCertificate, bool isInitiator) { return true; }

   /// Validates that the given public key is valid for this connection.  If this
   /// host requires a valid certificate for the communication, this function
   /// should always return false.  It will only be called if the remote side
   /// of the connection did not provide a certificate.
   virtual bool validatePublicKey(AsymmetricKey *theKey, bool isInitiator) { return true; }

   /// Fills the connect request packet with additional custom data (from a subclass).
   virtual void writeConnectRequest(BitStream *stream)
	{
	   write(*stream, U32(getNetClassGroup()));
	   write(*stream, U32(NetClassRegistry::GetClassGroupCRC(getNetClassGroup())));
	}

   /// Called after this connection instance is created on a non-initiating host (server).
   ///
   /// Reads data sent by the writeConnectRequest method and returns true if the connection is accepted
   /// or false if it's not.  The errorString pointer should be filled if the connection is rejected.
   virtual bool readConnectRequest(BitStream *stream, const char **errorString)
	{
	   U32 classGroup, classCRC;
	   read(*stream, &classGroup);
	   read(*stream, &classCRC);

	   if(classGroup == getNetClassGroup() && classCRC == NetClassRegistry::GetClassGroupCRC(getNetClassGroup()))
		  return true;

	   *errorString = "CHR_INVALID";
	   return false;
	}

   /// Writes any data needed to start the connection on the accept packet.
   virtual void writeConnectAccept(BitStream *stream)
	{
	   stream;
	}

   /// Reads out the extra data read by writeConnectAccept and returns true if it is processed properly.
   virtual bool readConnectAccept(BitStream *stream, const char **errorString)
	{
	   stream;
	   errorString;
	   return true;
	}

	/// Called to read a subclass's packet data from the packet.
   virtual void readPacket(BitStream *bstream) {}

	/// Called to prepare the connection for packet writing.
   virtual void prepareWritePacket() {}
   
                                       ///
                                       ///  Any setup work to determine if there isDataToTransmit() should happen in
                                       ///  this function.  prepareWritePacket should _always_ call the Parent:: function.

	/// Called to write a subclass's packet data into the packet.Information about what the instance wrote into the packet can be attached to the notify object.
   virtual void writePacket(BitStream *bstream, PacketNotify *note) {}

	/// Called when the packet associated with the specified notify is known to have been received by the remote host.  Packets are guaranteed to be notified in the order in which they were sent.
	virtual void packetReceived(PacketNotify *note)
	{
	   if(mStringTable)
		  mStringTable->packetReceived(&note->stringList);
	}
	
	/// Called when the packet associated with the specified notify is known to have been not received by the remote host.  Packets are guaranteed to be notified in the order in which they were sent.
	virtual void packetDropped(PacketNotify *note)
	{
	   if(mStringTable)
		  mStringTable->packetDropped(&note->stringList);
	}

   /// Allocates a data record to track data sent on an individual packet.  If you need to track additional notification information, you'll have to override this so you allocate a subclass of PacketNotify with extra fields.
   virtual PacketNotify *allocNotify() { return new PacketNotify; }

public:
   /// Returns the next send sequence that will be sent by this side.
   U32 getNextSendSequence() { return mLastSendSeq + 1; }

   /// Returns the sequence of the last packet sent by this connection, or
   /// the current packet's send sequence if called from within writePacket().
   U32 getLastSendSequence() { return mLastSendSeq; }

protected:
   /// Reads a raw packet from a BitStream, as dispatched from NetInterface.
   void readRawPacket(BitStream *bstream)
	{
	   if(mSimulatedPacketLoss && Random::readF() < mSimulatedPacketLoss)
	   {
		  TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: RECVDROP - %d", mNetAddress.toString(), getLastSendSequence()));
		  return;
	   }
	   TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: RECV- %d bytes", mNetAddress.toString(), bstream->getMaxReadBitPosition() >> 3));

	   mErrorString = "";
	   if(readPacketHeader(bstream))
	   {
		  mLastPacketRecvTime = mInterface->getProcessStartTime();

		  readPacketRateInfo(bstream);
		  bstream->setStringTableEntryCompressor(mStringTable);
		  readPacket(bstream);

		  if(!bstream->isValid() && mErrorString.isEmpty())
			 NetConnection::setLastError("Invalid Packet.");
		  if(!mErrorString.isEmpty())
			 getInterface()->handleConnectionError(this, mErrorString);
		  mErrorString = "";
	   }
	}


   /// Writes a full packet of the specified type into the BitStream
   void writeRawPacket(BitStream *bstream, NetPacketType packetType)
	{
	   writePacketHeader(bstream, packetType);
	   if(packetType == DataPacket)
	   {
		  PacketNotify *note = allocNotify();
		  if(!mNotifyQueueHead)
			 mNotifyQueueHead = note;
		  else
			 mNotifyQueueTail->nextPacket = note;
		  mNotifyQueueTail = note;
		  note->nextPacket = NULL;
		  note->sendTime = mInterface->getProcessStartTime();

		  writePacketRateInfo(bstream, note);
		  S32 start = bstream->getBitPosition();
		  bstream->setStringTableEntryCompressor(mStringTable);

		  TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: START %s", mNetAddress.toString(), getClassName()) );
		  writePacket(bstream, note);
		  TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: END %s - %d bits", mNetAddress.toString(), getClassName(), bstream->getBitPosition() - start) );
	   }
	   if(!mSymmetricCipher.isNull())
	   {
		  mSymmetricCipher->setupCounter(mLastSendSeq, mLastSeqRecvd, packetType, 0);
		  BitStreamHashAndEncrypt(bstream, MessageSignatureBytes, PacketHeaderByteSize, mSymmetricCipher);
	   }
	}

   /// Writes the notify protocol's packet header into the BitStream.
   void writePacketHeader(BitStream *bstream, NetPacketType packetType)
	{
	   if(windowFull() && packetType == DataPacket)
		  TORQUE_DEBUGBREAK();

	   S32 ackByteCount = ((mLastSeqRecvd - mLastRecvAckAck + 7) >> 3);
	   Assert(ackByteCount <= MaxAckByteCount, "ackByteCount exceeds MaxAckByteCount!");
	   
	   if(packetType == DataPacket)
		  mLastSendSeq++;
		  
	   stream->writeInt(packetType, 2);
	   stream->writeInt(mLastSendSeq, 5); // write the first 5 bits of the send sequence
	   stream->writeFlag(true); // high bit of first byte indicates this is a data packet.
	   stream->writeInt(mLastSendSeq >> 5, SequenceNumberBitSize - 5); // write the rest of the send sequence
	   stream->writeInt(mLastSeqRecvd, AckSequenceNumberBitSize);
	   stream->writeInt(0, PacketHeaderPadBits);

	   stream->writeRangedU32(ackByteCount, 0, MaxAckByteCount);

	   U32 wordCount = (ackByteCount + 3) >> 2;

	   for(U32 i = 0; i < wordCount; i++)
		  stream->writeInt(mAckMask[i], i == wordCount - 1 ?
			 (ackByteCount - (i * 4)) * 8 : 32);

	   Time sendDelay = mInterface->getProcessStartTime() - mLastPacketRecvTime;
	   if(sendDelay > millisecondsToTime(2047))
		  sendDelay = millisecondsToTime(2047);
	   stream->writeInt(U32(sendDelay.getMilliseconds() >> 3), 8);

	   // if we're resending this header, we can't advance the
	   // sequence recieved (in case this packet drops and the prev one
	   // goes through) 

	   if(packetType == DataPacket)
		  mLastSeqRecvdAtSend[mLastSendSeq & PacketWindowMask] = mLastSeqRecvd;

	   //if(isNetworkConnection())
	   //{
	   //   TorqueLogMessageFormatted(LogBlah, ("SND: mLSQ: %08x  pkLS: %08x  pt: %d abc: %d",
	   //      mLastSendSeq, mLastSeqRecvd, packetType, ackByteCount));
	   //}

	   TorqueLogMessageFormatted(LogConnectionProtocol, ("build hdr %d %d", mLastSendSeq, packetType));
	}

   /// Reads a notify protocol packet header from the BitStream and
   /// returns true if it was a data packet that needs more processing.
   bool readPacketHeader(BitStream *bstream)
	{
	   // read in the packet header:
	   //
	   //   2 bits packet type
	   //   low 5 bits of the packet sequence number
	   //   1 bit game packet
	   //   SequenceNumberBitSize-5 bits (packet seq number >> 5)
	   //   AckSequenceNumberBitSize bits ackstart seq number
	   //   PacketHeaderPadBits = 0 - padding to byte boundary
	   //   after this point, if this is an encrypted packet, all the rest of the data will be encrypted

	   //   rangedU32 - 0...MaxAckByteCount
	   //
	   // type is:
	   //    00 data packet
	   //    01 ping packet
	   //    02 ack packet
	   
	   // next 0...ackByteCount bytes are ack flags
	   //
	   // return value is true if this is a valid data packet
	   // or false if there is nothing more that should be read

	   U32 pkPacketType     = pstream->readInt(2);
	   U32 pkSequenceNumber = pstream->readInt(5);
	   bool pkDataPacketFlg = pstream->readFlag();
	   pkSequenceNumber = pkSequenceNumber | (pstream->readInt(SequenceNumberBitSize - 5) << 5);

	   U32 pkHighestAck     = pstream->readInt(AckSequenceNumberBitSize);
	   U32 pkPadBits        = pstream->readInt(PacketHeaderPadBits);

	   if(pkPadBits != 0)
		  return false;

	   Assert(pkDataPacketFlg, "Invalid packet header in NetConnection::readPacketHeader!");

	   // verify packet ordering and acking and stuff
	   // check if the 9-bit sequence is within the packet window
	   // (within 31 packets of the last received sequence number).

	   pkSequenceNumber |= (mLastSeqRecvd & SequenceNumberMask);
	   // account for wrap around
	   if(pkSequenceNumber < mLastSeqRecvd)
		  pkSequenceNumber += SequenceNumberWindowSize;
	   
	   // in the following test, account for wrap around from 0
	   if(pkSequenceNumber - mLastSeqRecvd > (MaxPacketWindowSize - 1))
	   {
		  // the sequence number is outside the window... must be out of order
		  // discard.
		  return false;
	   }

	   pkHighestAck |= (mHighestAckedSeq & AckSequenceNumberMask);
	   // account for wrap around
	   
	   if(pkHighestAck < mHighestAckedSeq)
		  pkHighestAck += AckSequenceNumberWindowSize;
	   
	   if(pkHighestAck > mLastSendSeq)
	   {
		  // the ack number is outside the window... must be an out of order
		  // packet, discard.
		  return false;
	   }
	   
	   if(!mSymmetricCipher.isNull())
	   {
		  mSymmetricCipher->setupCounter(pkSequenceNumber, pkHighestAck, pkPacketType, 0);
		  if(!BitStreamDecryptAndCheckHash(pstream, MessageSignatureBytes, PacketHeaderByteSize, mSymmetricCipher))
		  {
			 TorqueLogMessage(LogNetConnection, "Packet failed crypto");
			 return false;
		  }
	   }

	   U32 pkAckByteCount   = pstream->readRangedU32(0, MaxAckByteCount);
	   if(pkAckByteCount > MaxAckByteCount || pkPacketType >= InvalidPacketType)
		  return false;
			 
	   U32 pkAckMask[MaxAckMaskSize];
	   U32 pkAckWordCount = (pkAckByteCount + 3) >> 2;

	   for(U32 i = 0; i < pkAckWordCount; i++)
		  pkAckMask[i] = pstream->readInt(i == pkAckWordCount - 1 ? 
				(pkAckByteCount - (i * 4)) * 8 : 32);

	   //if(isNetworkConnection())
	   //{
	   //   TorqueLogMessageFormatted(LogBlah, ("RCV: mHA: %08x  pkHA: %08x  mLSQ: %08x  pkSN: %08x  pkLS: %08x  pkAM: %08x",
	   //      mHighestAckedSeq, pkHighestAck, mLastSendSeq, pkSequenceNumber, mLastSeqRecvd, pkAckMask[0]));
	   //}

	   Time pkSendDelay = millisecondsToTime((pstream->readInt(8) << 3) + 4);

	   TorqueLogBlock(LogConnectionProtocol,
		  for(U32 i = mLastSeqRecvd+1; i < pkSequenceNumber; i++)
			 logprintf ("Not recv %d", i);
		  logprintf("Recv %d %s", pkSequenceNumber, packetTypeNames[pkPacketType]);
	   );

	   // shift up the ack mask by the packet difference
	   // this essentially nacks all the packets dropped

	   U32 ackMaskShift = pkSequenceNumber - mLastSeqRecvd;

	   // if we've missed more than a full word of packets, shift up by words
	   while(ackMaskShift > 32)
	   {
		  for(S32 i = MaxAckMaskSize - 1; i > 0; i--)
			 mAckMask[i] = mAckMask[i-1];
		  mAckMask[0] = 0;
		  ackMaskShift -= 32;
	   }

	   // the first word upshifts all NACKs, except for the low bit, which is a
	   // 1 if this is a data packet (i.e. not a ping packet or an ack packet)
	   U32 upShifted = (pkPacketType == DataPacket) ? 1 : 0; 

	   for(U32 i = 0; i < MaxAckMaskSize; i++)
	   {
		  U32 nextShift = mAckMask[i] >> (32 - ackMaskShift);
		  mAckMask[i] = (mAckMask[i] << ackMaskShift) | upShifted;
		  upShifted = nextShift;
	   }

	   // do all the notifies...
	   U32 notifyCount = pkHighestAck - mHighestAckedSeq;
	   for(U32 i = 0; i < notifyCount; i++) 
	   {
		  U32 notifyIndex = mHighestAckedSeq + i + 1;

		  U32 ackMaskBit = (pkHighestAck - notifyIndex) & 0x1F;
		  U32 ackMaskWord = (pkHighestAck - notifyIndex) >> 5;

		  bool packetTransmitSuccess = (pkAckMask[ackMaskWord] & (1 << ackMaskBit)) != 0;
		  TorqueLogMessageFormatted(LogConnectionProtocol, ("Ack %d %d", notifyIndex, packetTransmitSuccess));

		  mHighestAckedSendTime = millisecondsToTime(0);
		  handleNotify(notifyIndex, packetTransmitSuccess);

		  // Running average of roundTrip time
		  if(mHighestAckedSendTime != Time(S64(0)))
		  {
			 Time roundTripDelta = mInterface->getProcessStartTime() - (mHighestAckedSendTime + pkSendDelay);
			 mRoundTripTime = mRoundTripTime * 0.9f + roundTripDelta.getMilliseconds() * 0.1f;
			 if(mRoundTripTime < 0)
				mRoundTripTime = 0;
		  }      
		  if(packetTransmitSuccess)
			 mLastRecvAckAck = mLastSeqRecvdAtSend[notifyIndex & PacketWindowMask];
	   }
	   // the other side knows more about its window than we do.
	   if(pkSequenceNumber - mLastRecvAckAck > MaxPacketWindowSize)
		  mLastRecvAckAck = pkSequenceNumber - MaxPacketWindowSize;
	   
	   mHighestAckedSeq = pkHighestAck;

	   // first things first...
	   // ackback any pings or half-full windows

	   keepAlive(); // notification that the connection is ok

	   U32 prevLastSequence = mLastSeqRecvd;
	   mLastSeqRecvd = pkSequenceNumber;

	   if(pkPacketType == PingPacket || (pkSequenceNumber - mLastRecvAckAck > (MaxPacketWindowSize >> 1)))
	   {
		  // send an ack to the other side
		  // the ack will have the same packet sequence as our last sent packet
		  // if the last packet we sent was the connection accepted packet
		  // we must resend that packet
		  sendAckPacket();
	   }
	   return prevLastSequence != pkSequenceNumber && pkPacketType == DataPacket;
	}

	/// Writes any packet send rate change information into the packet.
	void writePacketRateInfo(BitStream *bstream, PacketNotify *note)
	{
	   note->rateChanged = mLocalRateChanged;
	   mLocalRateChanged = false;
	   if(bstream->writeFlag(note->rateChanged))
	   {
		  if(!bstream->writeFlag(mTypeFlags.test(ConnectionAdaptive)))
		  {
			 bstream->writeRangedU32(mLocalRate.maxRecvBandwidth, 0, MaxFixedBandwidth);
			 bstream->writeRangedU32(mLocalRate.maxSendBandwidth, 0, MaxFixedBandwidth);
			 bstream->writeRangedU32(mLocalRate.minPacketRecvPeriod, 1, MaxFixedSendPeriod);
			 bstream->writeRangedU32(mLocalRate.minPacketSendPeriod, 1, MaxFixedSendPeriod);
		  }
	   }
	}

	/// Reads any packet send rate information requests from the packet.
   void readPacketRateInfo(BitStream *bstream)
	{
	   if(bstream->readFlag())
	   {
		  if(bstream->readFlag())
			 mTypeFlags.set(ConnectionRemoteAdaptive);
		  else
		  {
			 mRemoteRate.maxRecvBandwidth = bstream->readRangedU32(0, MaxFixedBandwidth);
			 mRemoteRate.maxSendBandwidth = bstream->readRangedU32(0, MaxFixedBandwidth);
			 mRemoteRate.minPacketRecvPeriod = bstream->readRangedU32(1, MaxFixedSendPeriod);
			 mRemoteRate.minPacketSendPeriod = bstream->readRangedU32(1, MaxFixedSendPeriod);
			 computeNegotiatedRate();
		  }
	   }
	}

   /// Sends a ping packet to the remote host, to determine if it is still alive and what its packet window status is.
   void sendPingPacket()
	{
	   PacketStream ps;
	   writeRawPacket(&ps, PingPacket);
	   TorqueLogMessageFormatted(LogConnectionProtocol, ("send ping %d", mLastSendSeq));

	   sendPacket(&ps);
	}

   /// Sends an ack packet to the remote host, in response to receiving a ping packet.
   void sendAckPacket()
	{
	   PacketStream ps;
	   writeRawPacket(&ps, AckPacket);
	   TorqueLogMessageFormatted(LogConnectionProtocol, ("send ack %d", mLastSendSeq));

	   sendPacket(&ps);
	}

   /// Dispatches a notify when a packet is ACK'd or NACK'd.
   void handleNotify(U32 sequence, bool recvd)
	{
	   TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: NOTIFY %d %s", mNetAddress.toString(), sequence, recvd ? "RECVD" : "DROPPED"));

	   PacketNotify *note = mNotifyQueueHead;
	   Assert(note != NULL, "Error: got a notify with a null notify head.");
	   mNotifyQueueHead = mNotifyQueueHead->nextPacket;

	   if(note->rateChanged && !recvd)
		  mLocalRateChanged = true;

	   if(recvd)
	   {
		  mHighestAckedSendTime = note->sendTime;

		  if(isAdaptive())
		  {
			 // Deal with updating our cwnd and ssthresh...
			 if(cwnd < ssthresh)
			 {
				// Slow start strategy
				cwnd++;
				TorqueLogMessageFormatted(LogNetConnection, ("PKT SSOK - ssthresh = %f     cwnd=%f", ssthresh, cwnd));

			 } else {
				// We are in normal state..
				if(cwnd < MaxPacketWindowSize-2)
				   cwnd += 1/cwnd;

				TorqueLogMessageFormatted(LogNetConnection, ("PKT   OK - ssthresh = %f     cwnd=%f", ssthresh, cwnd));

			 }
		  }

		  packetReceived(note);
	   }
	   else
	   {
		  if(isAdaptive())
		  {
			 // Deal with updating our cwnd and ssthresh...
			 ssthresh = (0.5f * ssthresh < 2) ? 2 : (0.5f * ssthresh);
			 cwnd -= 1;
			 if(cwnd < 2) cwnd = 2;

	/*         TorqueLogMessageFormatted(LogNetConnection, ("  * ack=%f   pktDt=%d    time=%f (%d)     seq=%d %d %d %d",
							ack,
							ackDelta,
							deltaT / 1000.0f,
							deltaT,
							mLastSeqRecvd,
							mLastRecvAckAck,
							mLastSeqRecvdAck,
							mHighestAckedSeq
			 )); */

		  }

		  packetDropped(note);
	   }
	   delete note;
	}


   /// Called when a packet is received to stop any timeout action in progress.
   void keepAlive()
	{
	   mLastPingSendTime = millisecondsToTime(0);
	   mPingSendCount = 0;
	}

	/// Clears out the pending notify list.
   void clearAllPacketNotifies() 
	{
	   while(mNotifyQueueHead)
		  handleNotify(0, false);
	}

public:
   /// Sets the initial sequence number of packets read from the remote host.
   void setInitialRecvSequence(U32 sequence)
	{ 
	   mInitialRecvSeq = mLastSeqRecvd = mLastRecvAckAck = sequence;
	}

   /// Returns the initial sequence number of packets sent from the remote host.
   U32 getInitialRecvSequence() { return mInitialRecvSeq; }

   /// Returns the initial sequence number of packets sent to the remote host.
   U32 getInitialSendSequence() { return mInitialSendSeq; }

   /// Connect to a server through a given network interface.  The connection request can require that the connection use encryption, or that the remote host's certificate be validated by a known Certificate Authority
   void connect(NetInterface *connectionInterface, const NetAddress &address, bool requestKeyExchange = false, bool requestCertificate = false)
   {
	   mConnectionParameters.mRequestKeyExchange = requestKeyExchange;
	   mConnectionParameters.mRequestCertificate = requestCertificate;
	   mConnectionParameters.mIsInitiator = true;

	   setNetAddress(address);
	   setInterface(theInterface);
	   mInterface->startConnection(this);
	}

   /// Connects to a server interface within the same process.
   bool connectLocal(NetInterface *connectionInterface, NetInterface *localServerInterface)
	{
	   Object *co = Object::create(getClassName());
	   NetConnection *client = this;
	   NetConnection *server = dynamic_cast<NetConnection *>(co);
	   const char *error = NULL;
	   PacketStream stream;

	   if(!server)
		   goto errorOut;

	   client->setInterface(connectionInterface);
	   client->getConnectionParameters().mIsInitiator = true;
	   client->getConnectionParameters().mIsLocal = true;
	   server->getConnectionParameters().mIsLocal = true;

	   server->setInterface(serverInterface);

	   server->setInitialRecvSequence(client->getInitialSendSequence());
	   client->setInitialRecvSequence(server->getInitialSendSequence());
	   client->setRemoteConnectionObject(server);
	   server->setRemoteConnectionObject(client);

	   stream.setBytePosition(0);
	   client->writeConnectRequest(&stream);
	   stream.setBytePosition(0);
	   if(!server->readConnectRequest(&stream, &error))
		  goto errorOut;

	   stream.setBytePosition(0);
	   server->writeConnectAccept(&stream);
	   stream.setBytePosition(0);

	   if(!client->readConnectAccept(&stream, &error))
		  goto errorOut;

	   client->setConnectionState(NetConnection::Connected);
	   server->setConnectionState(NetConnection::Connected);

	   client->onConnectionEstablished();
	   server->onConnectionEstablished();
	   connectionInterface->addConnection(client);
	   serverInterface->addConnection(server);
	   return true;
	errorOut:
	   delete server;
	   return false;
	}

   /// Connects to a remote host that is also connecting to this connection (negotiated by a third party)
   void connectArranged(NetInterface *connectionInterface, const Array<NetAddress> &possibleAddresses, Nonce &myNonce, Nonce &remoteNonce, ByteBufferPtr sharedSecret, bool isInitiator, bool requestsKeyExchange = false, bool requestsCertificate = false)
	{
	   mConnectionParameters.mRequestKeyExchange = requestsKeyExchange;
	   mConnectionParameters.mRequestCertificate = requestsCertificate;
	   mConnectionParameters.mPossibleAddresses = possibleAddresses;
	   mConnectionParameters.mIsInitiator = isInitiator;
	   mConnectionParameters.mIsArranged = true;
	   mConnectionParameters.mNonce = nonce;
	   mConnectionParameters.mServerNonce = serverNonce;
	   mConnectionParameters.mArrangedSecret = sharedSecret;

	   setInterface(connectionInterface);
	   mInterface->startArrangedConnection(this);   
	}

   /// Sends a disconnect packet to notify the remote host that this side is terminating the connection for the specified reason.
   /// This will remove the connection from its NetInterface, and may have the side
   /// effect that the connection is deleted, if there are no other objects with RefPtrs
   /// to the connection.
   void disconnect(const String &reason)
	{
	   mInterface->disconnect(this, ReasonSelfDisconnect, reason);
	}


   /// Returns true if the packet send window is full and no more data packets can be sent.
   bool windowFull()
   {
	   if(mLastSendSeq - mHighestAckedSeq >= (MaxPacketWindowSize - 2))
		  return true;
	   if(isAdaptive())
		  return mLastSendSeq - mHighestAckedSeq >= cwnd;
	   return false;
	}


   /// Structure used to track what was sent in an individual packet for processing
   /// upon notification of delivery success or failure.
   struct PacketNotify
   {
      // packet stream notify stuff:
      bool rateChanged;  ///< True if this packet requested a change of rate.
      Time sendTime;     ///< getRealMilliseconds() when packet was sent.
      ConnectionStringTable::PacketList stringList; ///< List of string table entries sent in this packet

      PacketNotify *nextPacket; ///< Pointer to the next packet sent on this connection
      PacketNotify()
		{
			rateChanged = false;
		}

   };

//----------------------------------------------------------------
// Connection functions
//----------------------------------------------------------------

   /// Flags specifying the type of the connection instance.
   enum NetConnectionTypeFlags {
      ConnectionToServer = Bit(0), ///< A connection to a "server", used for directing NetEvents
      ConnectionToClient = Bit(1), ///< A connection to a "client"
      ConnectionAdaptive = Bit(2), ///< Indicates that this connection uses the adaptive protocol.
      ConnectionRemoteAdaptive = Bit(3), ///< Indicates that the remote side of this connection requested the adaptive protocol.
   };

private:
   BitMask32 mTypeFlags;  ///< Flags describing the type of connection this is, OR'd from NetConnectionTypeFlags.
   Time mLastUpdateTime;  ///< The last time a packet was sent from this instance.
   F32 mRoundTripTime;   ///< Running average round trip time.
   Time mSendDelayCredit; ///< Metric to help compensate for irregularities on fixed rate packet sends.

   U32 mSimulatedLatency;    ///< Amount of additional time this connection delays its packet sends to simulate latency in the connection
   F32 mSimulatedPacketLoss; ///< Function to simulate packet loss on a network

   enum RateDefaults {
      DefaultFixedBandwidth  = 2500,  ///< The default send/receive bandwidth - 2.5 Kb per second.
      DefaultFixedSendPeriod = 96,    ///< The default delay between each packet send - approx 10 packets per second.
      MaxFixedBandwidth      = 65535, ///< The maximum bandwidth for a connection using the fixed rate transmission method.
      MaxFixedSendPeriod     = 2047,  ///< The maximum period between packets in the fixed rate send transmission method.
   };

   /// Rate management structure used specify the rate at which packets are sent and the maximum size of each packet.
   struct NetRate
   {
      U32 minPacketSendPeriod; ///< Minimum millisecond delay (maximum rate) between packet sends.
      U32 minPacketRecvPeriod; ///< Minimum millisecond delay the remote host should allow between sends.
      U32 maxSendBandwidth;    ///< Number of bytes per second we can send over the connection.
      U32 maxRecvBandwidth;    ///< Number of bytes per second max that the remote instance should send.
   };
    /// Called internally when the local or remote rate changes.
   void computeNegotiatedRate()
	{
	   mCurrentPacketSendPeriod = max(mLocalRate.minPacketSendPeriod, mRemoteRate.minPacketRecvPeriod);

	   U32 maxBandwidth = min(mLocalRate.maxSendBandwidth, mRemoteRate.maxRecvBandwidth);
	   mCurrentPacketSendSize = U32(maxBandwidth * mCurrentPacketSendPeriod * 0.001f);

	   // make sure we don't try to overwrite the maximum packet size
	   if(mCurrentPacketSendSize > NetSocket::MaxPacketDataSize)
		  mCurrentPacketSendSize = NetSocket::MaxPacketDataSize;
	}

   NetRate mLocalRate;           ///< Current communications rate negotiated for this connection.
   NetRate mRemoteRate;          ///< Maximum allowable communications rate for this connection.

   bool mLocalRateChanged;       ///< Set to true when the local connection's rate has changed.
   U32 mCurrentPacketSendSize;   ///< Current size of each packet sent to the remote host.
   U32 mCurrentPacketSendPeriod; ///< Millisecond delay between sent packets.

   NetAddress mNetAddress;       ///< The network address of the host this instance is connected to.

   // timeout management stuff:
   U32 mPingSendCount;    ///< Number of unacknowledged ping packets sent to the remote host
   Time mLastPingSendTime; ///< Last time a ping packet was sent from this connection

protected:
   PacketNotify *mNotifyQueueHead;  ///< Linked list of structures representing the data in sent packets
   PacketNotify *mNotifyQueueTail;  ///< Tail of the notify queue linked list.  New packets are added to the end of the tail.

   /// Returns the notify structure for the current packet write, or last written packet.
   PacketNotify *getCurrentWritePacketNotify() { return mNotifyQueueTail; }


   SafePtr<NetConnection> mRemoteConnection;  ///< Safe pointer to a short-circuit remote connection on the same host.
                                              ///
                                              ///  This currently isn't enabled - see the end of netConnection.cpp for an example
                                              ///  of how to use this. If it's set, the code will use short circuited networking.
   ConnectionParameters mConnectionParameters;
public:
   ConnectionParameters &getConnectionParameters() { return mConnectionParameters; }

   /// returns true if this object initiated the connection with the remote host
   bool isInitiator() { return mConnectionParameters.mIsInitiator; }
   void setRemoteConnectionObject(NetConnection *connection) { mRemoteConnection = connection; };
   NetConnection *getRemoteConnectionObject() { return mRemoteConnection; }

   U32 mConnectSendCount;    ///< Number of challenge or connect requests sent to the remote host.
   Time mConnectLastSendTime; ///< The send time of the last challenge or connect request.

protected:
public:
	/// returns the current error buffer
   String getErrorBuffer() { return mErrorString; } 
   
   /// Sets an error string and notifies the currently processing connection that it should terminate.
   void setLastError(const String &theString)    
	{
	   mErrorString = theString;
	   
	   Assert(0, mErrorString.c_str());
	}

protected:
   SafePtr<NetInterface> mInterface;             ///< The NetInterface of which this NetConnection is a member.
public:
	/// Sets the NetInterface this NetConnection will communicate through.
    void setInterface(NetInterface *myInterface)
	{
	   mInterface = myInterface;
	}
	
	/// Returns the NetInterface this connection communicates through.
	NetInterface *getInterface()
	{
	   return mInterface;
	}

protected:
	/// The helper object that performs symmetric encryption on packets
	RefPtr<SymmetricCipher> mSymmetricCipher;
public:
	/// Sets the SymmetricCipher this NetConnection will use for encryption
	void setSymmetricCipher(SymmetricCipher *theCipher)
	{
	   mSymmetricCipher = theCipher;
	}

public:
   /// Returns the class group of objects that can be transmitted over this NetConnection.
   virtual NetClassGroup getNetClassGroup() const { return NetClassGroupInvalid; }

   /// Sets the ping/timeout characteristics for a fixed-rate connection.  Total timeout is msPerPing * pingRetryCount.
   void setPingTimeouts(Time timePerPing, U32 pingRetryCount)
      { mPingRetryCount = pingRetryCount; mPingTimeout = timePerPing; }
   
   /// Simulates a network situation with a percentage random packet loss and a connection one way latency as specified.
   void setSimulatedNetParams(F32 packetLoss, U32 latency)
      { mSimulatedPacketLoss = packetLoss; mSimulatedLatency = latency; }

   /// Specifies that this NetConnection instance is a connection to a "server."
   void setIsConnectionToServer() { mTypeFlags.set(ConnectionToServer); }

   /// Returns true if this is a connection to a "server."
   bool isConnectionToServer()  { return mTypeFlags.test(ConnectionToServer); }

   /// Specifies that this NetConnection instance is a connection to a "client."
   void setIsConnectionToClient() { mTypeFlags.set(ConnectionToClient); }

   /// Returns true if this is a connection to a "client."
   bool isConnectionToClient()  { return mTypeFlags.test(ConnectionToClient); }

   /// Returns true if the remote side of this connection is a NetConnection instance in on the same host.
   bool isLocalConnection() { return !mRemoteConnection.isNull(); }

   /// Returns true if the remote side if this connection is on a remote host.
   bool isNetworkConnection() { return mRemoteConnection.isNull(); }

   /// Returns the running average packet round trip time.
   F32 getRoundTripTime()
      { return mRoundTripTime; }

   /// Returns have of the average of the round trip packet time.
   F32 getOneWayTime()
      { return mRoundTripTime * 0.5f; }

   /// Returns the remote address of the host we're connected or trying to connect to.
   const NetAddress &getNetAddress()
	{
	   return mNetAddress;
	}


   /// Returns the remote address in string form.
   String getNetAddressString() const { return mNetAddress.toString(); }

   /// Sets the address of the remote host we want to connect to.
   void setNetAddress(const NetAddress &address)
	{
	   mNetAddress = addr;
	}

   /// Sends a packet that was written into a BitStream to the remote host, or the mRemoteConnection on this host.
   NetSocket::Status sendPacket(BitStream *stream)
	{
	   if(mSimulatedPacketLoss && Random::readF() < mSimulatedPacketLoss)
	   {
		  TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: SENDDROP - %d", mNetAddress.toString(), getLastSendSequence()));
		  return NetSocket::OK;
	   }

	   TorqueLogMessageFormatted(LogNetConnection, ("NetConnection %s: SEND - %d bytes", mNetAddress.toString(), stream->getBytePosition()));

	   // do nothing on send if this is a demo replay.
	   if(isLocalConnection())
	   {
		  // short circuit connection to the other side.
		  // handle the packet, then force a notify.
		  U32 size = stream->getBytePosition();

		  stream->reset();
		  stream->setMaxSizes(size, 0);
		  
		  mRemoteConnection->readRawPacket(stream);
		  return NetSocket::OK;
	   }
	   else
	   {
		  if(mSimulatedLatency)
		  {
			 mInterface->sendtoDelayed(getNetAddress(), stream, mSimulatedLatency);
			 return NetSocket::OK;
		  }
		  else
			 return mInterface->sendto(getNetAddress(), stream);
	   }
	}

   /// Checks to see if the connection has timed out, possibly sending a ping packet to the remote host.  Returns true if the connection timed out.
   bool checkTimeout(Time time)
	{
	   if(!isNetworkConnection())
		  return false;

	   if(!mLastPingSendTime)
		  mLastPingSendTime = time;

	   Time timeout = mPingTimeout;
	   U32 timeoutCount = mPingRetryCount;

	   if(isAdaptive())
	   {
		  if(hasUnackedSentPackets())
		  {
			 timeout = millisecondsToTime(AdaptiveUnackedSentPingTimeout);
		  }
		  else
		  {
			 timeoutCount = AdaptivePingRetryCount;
			 if(!mPingSendCount)
				timeout = millisecondsToTime(AdaptiveInitialPingTimeout);
		  }
	   }
	   if((time - mLastPingSendTime) > timeout)
	   {
		  if(mPingSendCount >= timeoutCount)
			 return true;
		  mLastPingSendTime = time;
		  mPingSendCount++;
		  sendPingPacket();
	   }
	   return false;
	}

   /// Checks to see if a packet should be sent at the currentTime to the remote host.
   ///
   /// If force is true and there is space in the window, it will always send a packet.
   void checkPacketSend(bool force, Time currentTime)
	{
	   Time delay = millisecondsToTime( mCurrentPacketSendPeriod );

	   if(!force)
	   {
		  if(!isAdaptive())
		  {
			 if(curTime - mLastUpdateTime + mSendDelayCredit < delay)
				return;
		  
			 mSendDelayCredit = curTime - (mLastUpdateTime + delay - mSendDelayCredit);
			 if(mSendDelayCredit > millisecondsToTime(1000))
				mSendDelayCredit = millisecondsToTime(1000);
		  }
	   }
	   prepareWritePacket();
	   if(windowFull() || !isDataToTransmit())
	   {
		  // there is nothing to transmit, or the window is full
		  if(isAdaptive())
		  {
			 // Still, on an adaptive connection, we may need to send an ack here...

			 // Check if we should ack. We use a heuristic to do this. (fuzzy logic!)
			 S32 ackDelta = (mLastSeqRecvd - mLastSeqRecvdAck);
			 F32 ack = ackDelta / 4.0f;

			 // Multiply by the time since we've acked...
			 // If we're much below 200, we don't want to ack; if we're much over we do.
			 Time deltaT = (curTime - mLastAckTime);
			 ack = ack *  deltaT.getMilliseconds() / 200.0f;

			 if((ack > 1.0f || (ackDelta > (0.75*MaxPacketWindowSize))) && (mLastSeqRecvdAck != mLastSeqRecvd))
			 {         
				mLastSeqRecvdAck = mLastSeqRecvd;
				mLastAckTime = curTime;
				sendAckPacket();
			 }
		  }
		  return;
	   }
	   PacketStream stream(mCurrentPacketSendSize);
	   mLastUpdateTime = curTime;

	   writeRawPacket(&stream, DataPacket);   

	   sendPacket(&stream);
	}

   /// Connection state flags for a NetConnection instance.
   enum NetConnectionState {
      NotConnected=0,            ///< Initial state of a NetConnection instance - not connected.
      AwaitingChallengeResponse, ///< We've sent a challenge request, awaiting the response.
      SendingPunchPackets,       ///< The state of a pending arranged connection when both sides haven't heard from the other yet
      ComputingPuzzleSolution,   ///< We've received a challenge response, and are in the process of computing a solution to its puzzle.
      AwaitingConnectResponse,   ///< We've received a challenge response and sent a connect request.
      ConnectTimedOut,           ///< The connection timed out during the connection process.
      ConnectRejected,           ///< The connection was rejected.
      Connected,                 ///< We've accepted a connect request, or we've received a connect response accept.
      Disconnected,              ///< The connection has been disconnected.
      TimedOut,                  ///< The connection timed out.
      StateCount,
   };

   NetConnectionState mConnectionState; ///< Current state of this NetConnection.

   /// Sets the current connection state of this NetConnection.
   void setConnectionState(NetConnectionState state) { mConnectionState = state; }

   /// Gets the current connection state of this NetConnection.
   NetConnectionState getConnectionState() { return mConnectionState; }

   /// Returns true if the connection handshaking has completed successfully.
   bool isEstablished() { return mConnectionState == Connected; }

   /// @name Adaptive Protocol
   ///
   /// Functions and state for the adaptive rate protocol.
   ///
   /// TNL's adaptive rate uses rate control algorithms similar to
   /// TCP/IP's.
   ///
   /// There are a few state variables here that aren't documented.
   ///
   /// @{

public:

   /// Enables the adaptive protocol.
   ///
   /// By default NetConnection operates with a fixed rate protocol - that is, it sends a
   /// packet every few milliseconds, based on some configuration parameters. However,
   /// it is possible to use an adaptive rate protocol that attempts to maximize thoroughput
   /// over the connection.
   ///
   /// Calling this function enables this behavior.
   void setIsAdaptive()
	{
	   mTypeFlags.set(ConnectionAdaptive);
	   mLocalRateChanged = true;
	}


   /// sets the fixed rate send and receive data sizes, and sets the connection to not behave as an adaptive rate connection
   void setFixedRateParameters( U32 minPacketSendPeriod, U32 minPacketRecvPeriod, U32 maxSendBandwidth, U32 maxRecvBandwidth )
	{
	   mTypeFlags.clear(ConnectionAdaptive);

	   mLocalRate.maxRecvBandwidth = maxRecvBandwidth;
	   mLocalRate.maxSendBandwidth = maxSendBandwidth;
	   mLocalRate.minPacketRecvPeriod = minPacketRecvPeriod;
	   mLocalRate.minPacketSendPeriod = minPacketSendPeriod;
	   mLocalRateChanged = true;
	   computeNegotiatedRate();
	}

   /// Query the adaptive status of the connection.
   bool isAdaptive()    { return mTypeFlags.test(ConnectionAdaptive | ConnectionRemoteAdaptive); }

   /// Returns true if this connection has data to transmit.
   ///
   /// The adaptive rate protocol needs to be able to tell if there is data
   /// ready to be sent, so that it can avoid sending unnecessary packets.
   /// Each subclass of NetConnection may need to send different data - events,
   /// ghost updates, or other things. Therefore, this hook is provided so
   /// that child classes can overload it and let the adaptive protocol
   /// function properly.
   ///
   /// @note Make sure this calls to its parents - the accepted idiom is:
   ///       @code
   ///       return Parent::isDataToTransmit() || localConditions();
   ///       @endcode
   virtual bool isDataToTransmit() { return false; }


private:
   F32 cwnd;
   F32 ssthresh;
   U32 mLastSeqRecvdAck;
   Time mLastAckTime;

   /// @}
private:
   ConnectionStringTable *mStringTable; ///< Helper for managing translation between global NetStringTable ids to local ids for this connection.
public:
   /// Enables string tag translation on this connection.
   void setTranslatesStrings()
	{
	   if(!mStringTable) 
		  mStringTable = new ConnectionStringTable(this);
	}
};

static const U32 MinimumPaddingBits = 128;       ///< Padding space that is required at the end of each packet for bit flag writes and such.
